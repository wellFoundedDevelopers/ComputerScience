# Array / Linked List

## Array - 배열

자료형이 같은 데이터를 나열하여 **메모리에 연속으로 저장**하여 만든 자료 그룹

### 배열의 특징

- 크기가 고정되어 있음.
- 배열 요소를 구별하기 위해 번호를 사용함 (인덱스)
    - 인덱스는 0부터 시작
- 모든 자료형을 배열로 구성할 수 있음.
- 메모리에 연속적으로 배치되어있음.
- 데이터가 삭제되어도 삭제된 원소의 공간이 유지된다. `즉, element의 index는 변하지 않음.`
    > 인덱스 자체를 삭제하는 것이 아닌 인덱스에 존재하는 값(데이터)의 변경
    - 크기가 10인 정수형 배열이 있다.(값은 모두 7)

      0 1 2 3 4 5 6 7 8 9  
      7 7 7 7 7 7 7 7 7 7  
      <br>
      여기서  
      5번 인덱스의 7을 제거해도 나머지 값들의 인덱스는 바뀌지 않음.

      0 1 2 3 4 5 6 7 8 9  
      7 7 7 7 7 &nbsp;&nbsp; 7 7 7 7
- 운영체제의 cache locality를 활용할 수 있음.
    - cache hit의 가능성이 커져서 성능이 향상됨.
- random access가 가능함.
  - Random access means that you can access any array element by it's index in O(1) time.
- 순차 탐색을 하는 경우에도 물리적으로 연속된 메모리에 할당이 되어있으므로 LinkedList보다 성능이 좋음!

### 배열의 한계

- 인덱스에 따라서 값을 유지하기 때문에 인덱스 자리에 원소가 삭제되어도 빈자리가 남게 되어 메모리가 낭비됨.
- 크기가 고정된 자료구조이기 때문에, 100개의 크기로 할당한 후 원소를 1개만 사용하더라도 100칸의 메모리를 차지하여 메모리가 낭비됨.

| 구분        | 순차 자료구조                                                                | 연결 자료구조                                                   |
|-----------|------------------------------------------------------------------------|-----------------------------------------------------------|
| 메모리 저장 방식 | 메모리의 저장 시작 위치부터 빈자리 없이 자료를 순서대로 연속하여 저장                                | 메모리에 저장된 물리적 위치나 물리적 순서와 상관없이 링크에 의해 논리적인 순서를 표현          |
| 연산 특징     | 삽입/삭제 연산을 해도 빈자리 없이 자료가 순서대로 연속하여 저장됨.  변경된 논리적인 순서와 저장된 물리적인 순서가 일치함. | 삽입/삭제 연산을 하여 논리적인 순서가 변경되어도, 링크 정보만 변경되고 물리적 순서는 변경되지 않음. |
| 프로그램 기법   | 배열을 이용                                                                 | 포인터를 이용                                                   |

## 리스트

- ~~배열의 인덱스를 활용한 장점은 버리고~~,`빈 공간이 없는 데이터를 저장하는 자료구조`
    - 배열은 인덱스를 이용하여 데이터 조회를 빠르게 할 수 있음.
      그러기 위해서는 인덱스는 원소에 대한 고정값이어야 함.
        - 이에따라 배열의 원소가 삭제되어도 해당 공간을 빈공간으로 두어야하고 메모리를 낭비하게 됨.
          ⇒ 데이터를 꺼낼 때 빈값(null)인지 아닌지 확인할 필요성이 생김.
    - 리스트는 배열이 가지는 인덱스의 장점은 버리고 빈 공간이 없는 데이터를 저장하도록 만들어짐.
- ~~배열과 다르게 index가 중요하지 않음.~~
  > 배열의 경우에는 인덱스에도 의미 부여가 가능.
  알파벳 배열을 만들 때 인덱스의 값을 고유한 키값처럼 활용이 가능.
    - 배열은 원소가 삭제, 추가되어도 index가 변경되지 않지만,
      리스트는 빈공간이 없도록 유지하기위하여 index가 변경됨.
    - 리스트는 인덱스 자체보다는 원소들의 순서가 중요함.  


## ArrayList - 순차 리스트

`배열을 이용하여 구현한 리스트`

- 내부적으로 데이터를 배열에 저장함.
    - `인덱스를 통한 데이터를 조회`를 진행할 경우는 배열을 사용하기 때문에 성능이 뛰어남.
    - 단순 데이터를 추가하는 경우,
        - 배열의 크기보다 원소의 개수가 많아진다면 배열을 새로 생성하여 데이터를 옮기게 됨.
        - 그렇지 않다면 배열의 가장 마지막 빈자리에 데이터를 추가
    - 단순 데이터를 삭제하는 경우
        - 배열에 있는 마지막 데이터를 삭제.
    - `중간에 데이터를 삽입`하거나 `중간의 데이터 삭제`가 이루어진다면 새로운 배열을 생성하고 거기에 수정된 물리적인 순서에 맞춰 저장하게 됨.
      ⇒ 물리적인 순서를 맞추기 위한 오버헤드가 발생.

### 순차 리스트의 한계

- 배열로 구현이 되어있어, 리스트의 중간에 삽입 혹은 삭제 연산이 이루어지면 빈 공간을 없애기 위한 작업의 오버헤드가 발생함.

## LinkedList - 연결 리스트

`각 노드에 저장된 다음 노드의 주소에 의해 연결된 리스트`

- 노드에 저장된 다음 노드의 주소에 데이터를 저장함.
- 메모리가 물리적으로 연속될 필요가 없으므로 삽입, 삭제 연산을 할 때 오버헤드가 발생하지 않음.  
  > `(배열을 생성하거나 복사하는 오버헤드는 발생하지 않지만, 포인터를 생성하는 것도 오버헤드라고 볼 수가 있음)`
- 인덱스를 통한 `임의 접근이 불가능`함.
- 탐색을 하기 위해서 순차적으로 연결된 노드들을 하나씩 탐색해야함.

### 연결 리스트의 종류

- 단일 연결 리스트
    - 단방향으로 연결되어 있는 연결 리스트  
      → `이전 노드에 접근하기 위해서는 처음부터 다시 순차 탐색을 진행해야함.`
- 이중 연결 리스트
    - 양방향으로 연결되어 있는 연결 리스트  
      → `이전 노드에 직접 접근이 가능!`
- 원형 연결 리스트
    - 마지막 노드와 첫 번째 노드가 연결되어 있는 연결 리스트  
      → `한 방향(다음 노드)로만 순차 탐색을 진행하면 이전 노드에 접근할 수 있음.`

### 연결 리스트의 한계

- 특정 인덱스에 접근하기 위하여 반드시 순차 탐색을 진행해야함.
- 순차 탐색을 진행하는 속도도 물리적으로 연속적인 배열보다 느림.

## ArrayList VS Linked List

### ArrayList

- 인덱스를 이용한 데이터의 접근 혹은 탐색이 많을 경우 사용하기 용이함.
- 시간 복잡도
    - 특정 인덱스에 접근: O(1)
    - 삽입 / 삭제(탐색을 제외): O(1) + 물리적인 순서를 맞추기 위하여 오버헤드가 발생 == O(n)

### Linked List

- 데이터의 삽입 삭제가 많을 경우 사용하기 용이함.
- 시간 복잡도
    - 특정 인덱스에 접근: O(n)
    - 삽입 / 삭제(탐색을 제외): O(1)